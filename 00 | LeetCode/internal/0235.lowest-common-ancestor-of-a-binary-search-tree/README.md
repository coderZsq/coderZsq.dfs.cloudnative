## LeetCode 235 二叉搜索树的最近公共祖先 [简单]

### 题目描述

- https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

示例 1：

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

示例 2：

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

说明:

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

---

### 题解 1 (分治)

#### 基本流程

```
1. 分别在左右子树中查找 p, q (找到1个即可返回)
2. 判断 如果在左子树找不到 p, q 即 p, q 在右子树中, 返回右子树查找的值
3. 判断 如果在右子树找不到 p, q 即 p, q 在左子树中, 返回左子树查找的值
4. 如果 p, q 分别在左右子树中, 即 最近的公共祖先为 root 节点
```

### 题解 2 (二分搜索 + 递归)

```
0. 因为二叉搜索树中序遍历的特性是 left < root < right
1. 使用二分搜索进行查找
2. p, q 均小于 root, 则往 左子树查找
3. p, q 均大于 root, 则往 右子树查找
4. 如果 p, q 分别分布在 root 两侧, 则 root 为最近的公共祖先
```

### 题解 3 (二分搜索 + 迭代)

```
思路与题解2 相同, 使用迭代的方式
```
